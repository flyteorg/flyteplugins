// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import context "context"
import core "github.com/lyft/flyteidl/gen/pb-go/flyteidl/core"
import mock "github.com/stretchr/testify/mock"
import types "github.com/lyft/flyteplugins/go/tasks/v1/types"

// Executor is an autogenerated mock type for the Executor type
type Executor struct {
	mock.Mock
}

// CheckTaskStatus provides a mock function with given fields: ctx, taskCtx, task
func (_m *Executor) CheckTaskStatus(ctx context.Context, taskCtx types.TaskContext, task *core.TaskTemplate) (types.TaskStatus, error) {
	ret := _m.Called(ctx, taskCtx, task)

	var r0 types.TaskStatus
	if rf, ok := ret.Get(0).(func(context.Context, types.TaskContext, *core.TaskTemplate) types.TaskStatus); ok {
		r0 = rf(ctx, taskCtx, task)
	} else {
		r0 = ret.Get(0).(types.TaskStatus)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TaskContext, *core.TaskTemplate) error); ok {
		r1 = rf(ctx, taskCtx, task)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetID provides a mock function with given fields:
func (_m *Executor) GetID() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetProperties provides a mock function with given fields:
func (_m *Executor) GetProperties() types.ExecutorProperties {
	ret := _m.Called()

	var r0 types.ExecutorProperties
	if rf, ok := ret.Get(0).(func() types.ExecutorProperties); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(types.ExecutorProperties)
	}

	return r0
}

// Initialize provides a mock function with given fields: ctx, param
func (_m *Executor) Initialize(ctx context.Context, param types.ExecutorInitializationParameters) error {
	ret := _m.Called(ctx, param)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.ExecutorInitializationParameters) error); ok {
		r0 = rf(ctx, param)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KillTask provides a mock function with given fields: ctx, taskCtx, reason
func (_m *Executor) KillTask(ctx context.Context, taskCtx types.TaskContext, reason string) error {
	ret := _m.Called(ctx, taskCtx, reason)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TaskContext, string) error); ok {
		r0 = rf(ctx, taskCtx, reason)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResolveOutputs provides a mock function with given fields: ctx, taskCtx, outputVariables
func (_m *Executor) ResolveOutputs(ctx context.Context, taskCtx types.TaskContext, outputVariables ...string) (map[string]*core.Literal, error) {
	_va := make([]interface{}, len(outputVariables))
	for _i := range outputVariables {
		_va[_i] = outputVariables[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, taskCtx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 map[string]*core.Literal
	if rf, ok := ret.Get(0).(func(context.Context, types.TaskContext, ...string) map[string]*core.Literal); ok {
		r0 = rf(ctx, taskCtx, outputVariables...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*core.Literal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TaskContext, ...string) error); ok {
		r1 = rf(ctx, taskCtx, outputVariables...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartTask provides a mock function with given fields: ctx, taskCtx, task, inputs
func (_m *Executor) StartTask(ctx context.Context, taskCtx types.TaskContext, task *core.TaskTemplate, inputs *core.LiteralMap) (types.TaskStatus, error) {
	ret := _m.Called(ctx, taskCtx, task, inputs)

	var r0 types.TaskStatus
	if rf, ok := ret.Get(0).(func(context.Context, types.TaskContext, *core.TaskTemplate, *core.LiteralMap) types.TaskStatus); ok {
		r0 = rf(ctx, taskCtx, task, inputs)
	} else {
		r0 = ret.Get(0).(types.TaskStatus)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TaskContext, *core.TaskTemplate, *core.LiteralMap) error); ok {
		r1 = rf(ctx, taskCtx, task, inputs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
