// Code generated by mockery v1.0.1. DO NOT EDIT.

package mocks

import arraystatus "github.com/lyft/flyteplugins/go/tasks/plugins/array/arraystatus"
import bitarray "github.com/lyft/flytestdlib/bitarray"
import core "github.com/lyft/flyteplugins/go/tasks/plugins/array/core"
import flyteidlcore "github.com/lyft/flyteidl/gen/pb-go/flyteidl/core"
import mock "github.com/stretchr/testify/mock"

// State is an autogenerated mock type for the State type
type State struct {
	mock.Mock
}

type State_GetArrayStatus struct {
	*mock.Call
}

func (_m State_GetArrayStatus) Return(_a0 arraystatus.ArrayStatus) *State_GetArrayStatus {
	return &State_GetArrayStatus{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnGetArrayStatus() *State_GetArrayStatus {
	c := _m.On("GetArrayStatus")
	return &State_GetArrayStatus{Call: c}
}

func (_m *State) OnGetArrayStatusMatch(matchers ...interface{}) *State_GetArrayStatus {
	c := _m.On("GetArrayStatus", matchers...)
	return &State_GetArrayStatus{Call: c}
}

// GetArrayStatus provides a mock function with given fields:
func (_m *State) GetArrayStatus() arraystatus.ArrayStatus {
	ret := _m.Called()

	var r0 arraystatus.ArrayStatus
	if rf, ok := ret.Get(0).(func() arraystatus.ArrayStatus); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(arraystatus.ArrayStatus)
	}

	return r0
}

type State_GetExecutionArraySize struct {
	*mock.Call
}

func (_m State_GetExecutionArraySize) Return(_a0 int) *State_GetExecutionArraySize {
	return &State_GetExecutionArraySize{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnGetExecutionArraySize() *State_GetExecutionArraySize {
	c := _m.On("GetExecutionArraySize")
	return &State_GetExecutionArraySize{Call: c}
}

func (_m *State) OnGetExecutionArraySizeMatch(matchers ...interface{}) *State_GetExecutionArraySize {
	c := _m.On("GetExecutionArraySize", matchers...)
	return &State_GetExecutionArraySize{Call: c}
}

// GetExecutionArraySize provides a mock function with given fields:
func (_m *State) GetExecutionArraySize() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

type State_GetExecutionErr struct {
	*mock.Call
}

func (_m State_GetExecutionErr) Return(_a0 *flyteidlcore.ExecutionError) *State_GetExecutionErr {
	return &State_GetExecutionErr{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnGetExecutionErr() *State_GetExecutionErr {
	c := _m.On("GetExecutionErr")
	return &State_GetExecutionErr{Call: c}
}

func (_m *State) OnGetExecutionErrMatch(matchers ...interface{}) *State_GetExecutionErr {
	c := _m.On("GetExecutionErr", matchers...)
	return &State_GetExecutionErr{Call: c}
}

// GetExecutionErr provides a mock function with given fields:
func (_m *State) GetExecutionErr() *flyteidlcore.ExecutionError {
	ret := _m.Called()

	var r0 *flyteidlcore.ExecutionError
	if rf, ok := ret.Get(0).(func() *flyteidlcore.ExecutionError); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flyteidlcore.ExecutionError)
		}
	}

	return r0
}

type State_GetIndexesToCache struct {
	*mock.Call
}

func (_m State_GetIndexesToCache) Return(_a0 *bitarray.BitSet) *State_GetIndexesToCache {
	return &State_GetIndexesToCache{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnGetIndexesToCache() *State_GetIndexesToCache {
	c := _m.On("GetIndexesToCache")
	return &State_GetIndexesToCache{Call: c}
}

func (_m *State) OnGetIndexesToCacheMatch(matchers ...interface{}) *State_GetIndexesToCache {
	c := _m.On("GetIndexesToCache", matchers...)
	return &State_GetIndexesToCache{Call: c}
}

// GetIndexesToCache provides a mock function with given fields:
func (_m *State) GetIndexesToCache() *bitarray.BitSet {
	ret := _m.Called()

	var r0 *bitarray.BitSet
	if rf, ok := ret.Get(0).(func() *bitarray.BitSet); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bitarray.BitSet)
		}
	}

	return r0
}

type State_GetOriginalArraySize struct {
	*mock.Call
}

func (_m State_GetOriginalArraySize) Return(_a0 int64) *State_GetOriginalArraySize {
	return &State_GetOriginalArraySize{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnGetOriginalArraySize() *State_GetOriginalArraySize {
	c := _m.On("GetOriginalArraySize")
	return &State_GetOriginalArraySize{Call: c}
}

func (_m *State) OnGetOriginalArraySizeMatch(matchers ...interface{}) *State_GetOriginalArraySize {
	c := _m.On("GetOriginalArraySize", matchers...)
	return &State_GetOriginalArraySize{Call: c}
}

// GetOriginalArraySize provides a mock function with given fields:
func (_m *State) GetOriginalArraySize() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

type State_GetOriginalMinSuccesses struct {
	*mock.Call
}

func (_m State_GetOriginalMinSuccesses) Return(_a0 int64) *State_GetOriginalMinSuccesses {
	return &State_GetOriginalMinSuccesses{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnGetOriginalMinSuccesses() *State_GetOriginalMinSuccesses {
	c := _m.On("GetOriginalMinSuccesses")
	return &State_GetOriginalMinSuccesses{Call: c}
}

func (_m *State) OnGetOriginalMinSuccessesMatch(matchers ...interface{}) *State_GetOriginalMinSuccesses {
	c := _m.On("GetOriginalMinSuccesses", matchers...)
	return &State_GetOriginalMinSuccesses{Call: c}
}

// GetOriginalMinSuccesses provides a mock function with given fields:
func (_m *State) GetOriginalMinSuccesses() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

type State_GetPhase struct {
	*mock.Call
}

func (_m State_GetPhase) Return(phase core.Phase, version uint32) *State_GetPhase {
	return &State_GetPhase{Call: _m.Call.Return(phase, version)}
}

func (_m *State) OnGetPhase() *State_GetPhase {
	c := _m.On("GetPhase")
	return &State_GetPhase{Call: c}
}

func (_m *State) OnGetPhaseMatch(matchers ...interface{}) *State_GetPhase {
	c := _m.On("GetPhase", matchers...)
	return &State_GetPhase{Call: c}
}

// GetPhase provides a mock function with given fields:
func (_m *State) GetPhase() (core.Phase, uint32) {
	ret := _m.Called()

	var r0 core.Phase
	if rf, ok := ret.Get(0).(func() core.Phase); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(core.Phase)
	}

	var r1 uint32
	if rf, ok := ret.Get(1).(func() uint32); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(uint32)
	}

	return r0, r1
}

type State_GetReason struct {
	*mock.Call
}

func (_m State_GetReason) Return(_a0 string) *State_GetReason {
	return &State_GetReason{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnGetReason() *State_GetReason {
	c := _m.On("GetReason")
	return &State_GetReason{Call: c}
}

func (_m *State) OnGetReasonMatch(matchers ...interface{}) *State_GetReason {
	c := _m.On("GetReason", matchers...)
	return &State_GetReason{Call: c}
}

// GetReason provides a mock function with given fields:
func (_m *State) GetReason() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

type State_SetActualArraySize struct {
	*mock.Call
}

func (_m State_SetActualArraySize) Return(_a0 core.State) *State_SetActualArraySize {
	return &State_SetActualArraySize{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnSetActualArraySize(size int) *State_SetActualArraySize {
	c := _m.On("SetActualArraySize", size)
	return &State_SetActualArraySize{Call: c}
}

func (_m *State) OnSetActualArraySizeMatch(matchers ...interface{}) *State_SetActualArraySize {
	c := _m.On("SetActualArraySize", matchers...)
	return &State_SetActualArraySize{Call: c}
}

// SetActualArraySize provides a mock function with given fields: size
func (_m *State) SetActualArraySize(size int) core.State {
	ret := _m.Called(size)

	var r0 core.State
	if rf, ok := ret.Get(0).(func(int) core.State); ok {
		r0 = rf(size)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(core.State)
		}
	}

	return r0
}

type State_SetArrayStatus struct {
	*mock.Call
}

func (_m State_SetArrayStatus) Return(_a0 core.State) *State_SetArrayStatus {
	return &State_SetArrayStatus{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnSetArrayStatus(state arraystatus.ArrayStatus) *State_SetArrayStatus {
	c := _m.On("SetArrayStatus", state)
	return &State_SetArrayStatus{Call: c}
}

func (_m *State) OnSetArrayStatusMatch(matchers ...interface{}) *State_SetArrayStatus {
	c := _m.On("SetArrayStatus", matchers...)
	return &State_SetArrayStatus{Call: c}
}

// SetArrayStatus provides a mock function with given fields: state
func (_m *State) SetArrayStatus(state arraystatus.ArrayStatus) core.State {
	ret := _m.Called(state)

	var r0 core.State
	if rf, ok := ret.Get(0).(func(arraystatus.ArrayStatus) core.State); ok {
		r0 = rf(state)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(core.State)
		}
	}

	return r0
}

type State_SetExecutionErr struct {
	*mock.Call
}

func (_m State_SetExecutionErr) Return(_a0 core.State) *State_SetExecutionErr {
	return &State_SetExecutionErr{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnSetExecutionErr(err *flyteidlcore.ExecutionError) *State_SetExecutionErr {
	c := _m.On("SetExecutionErr", err)
	return &State_SetExecutionErr{Call: c}
}

func (_m *State) OnSetExecutionErrMatch(matchers ...interface{}) *State_SetExecutionErr {
	c := _m.On("SetExecutionErr", matchers...)
	return &State_SetExecutionErr{Call: c}
}

// SetExecutionErr provides a mock function with given fields: err
func (_m *State) SetExecutionErr(err *flyteidlcore.ExecutionError) core.State {
	ret := _m.Called(err)

	var r0 core.State
	if rf, ok := ret.Get(0).(func(*flyteidlcore.ExecutionError) core.State); ok {
		r0 = rf(err)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(core.State)
		}
	}

	return r0
}

type State_SetIndexesToCache struct {
	*mock.Call
}

func (_m State_SetIndexesToCache) Return(_a0 core.State) *State_SetIndexesToCache {
	return &State_SetIndexesToCache{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnSetIndexesToCache(set *bitarray.BitSet) *State_SetIndexesToCache {
	c := _m.On("SetIndexesToCache", set)
	return &State_SetIndexesToCache{Call: c}
}

func (_m *State) OnSetIndexesToCacheMatch(matchers ...interface{}) *State_SetIndexesToCache {
	c := _m.On("SetIndexesToCache", matchers...)
	return &State_SetIndexesToCache{Call: c}
}

// SetIndexesToCache provides a mock function with given fields: set
func (_m *State) SetIndexesToCache(set *bitarray.BitSet) core.State {
	ret := _m.Called(set)

	var r0 core.State
	if rf, ok := ret.Get(0).(func(*bitarray.BitSet) core.State); ok {
		r0 = rf(set)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(core.State)
		}
	}

	return r0
}

type State_SetOriginalArraySize struct {
	*mock.Call
}

func (_m State_SetOriginalArraySize) Return(_a0 core.State) *State_SetOriginalArraySize {
	return &State_SetOriginalArraySize{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnSetOriginalArraySize(size int64) *State_SetOriginalArraySize {
	c := _m.On("SetOriginalArraySize", size)
	return &State_SetOriginalArraySize{Call: c}
}

func (_m *State) OnSetOriginalArraySizeMatch(matchers ...interface{}) *State_SetOriginalArraySize {
	c := _m.On("SetOriginalArraySize", matchers...)
	return &State_SetOriginalArraySize{Call: c}
}

// SetOriginalArraySize provides a mock function with given fields: size
func (_m *State) SetOriginalArraySize(size int64) core.State {
	ret := _m.Called(size)

	var r0 core.State
	if rf, ok := ret.Get(0).(func(int64) core.State); ok {
		r0 = rf(size)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(core.State)
		}
	}

	return r0
}

type State_SetOriginalMinSuccesses struct {
	*mock.Call
}

func (_m State_SetOriginalMinSuccesses) Return(_a0 core.State) *State_SetOriginalMinSuccesses {
	return &State_SetOriginalMinSuccesses{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnSetOriginalMinSuccesses(size int64) *State_SetOriginalMinSuccesses {
	c := _m.On("SetOriginalMinSuccesses", size)
	return &State_SetOriginalMinSuccesses{Call: c}
}

func (_m *State) OnSetOriginalMinSuccessesMatch(matchers ...interface{}) *State_SetOriginalMinSuccesses {
	c := _m.On("SetOriginalMinSuccesses", matchers...)
	return &State_SetOriginalMinSuccesses{Call: c}
}

// SetOriginalMinSuccesses provides a mock function with given fields: size
func (_m *State) SetOriginalMinSuccesses(size int64) core.State {
	ret := _m.Called(size)

	var r0 core.State
	if rf, ok := ret.Get(0).(func(int64) core.State); ok {
		r0 = rf(size)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(core.State)
		}
	}

	return r0
}

type State_SetPhase struct {
	*mock.Call
}

func (_m State_SetPhase) Return(_a0 core.State) *State_SetPhase {
	return &State_SetPhase{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnSetPhase(phase core.Phase, phaseVersion uint32) *State_SetPhase {
	c := _m.On("SetPhase", phase, phaseVersion)
	return &State_SetPhase{Call: c}
}

func (_m *State) OnSetPhaseMatch(matchers ...interface{}) *State_SetPhase {
	c := _m.On("SetPhase", matchers...)
	return &State_SetPhase{Call: c}
}

// SetPhase provides a mock function with given fields: phase, phaseVersion
func (_m *State) SetPhase(phase core.Phase, phaseVersion uint32) core.State {
	ret := _m.Called(phase, phaseVersion)

	var r0 core.State
	if rf, ok := ret.Get(0).(func(core.Phase, uint32) core.State); ok {
		r0 = rf(phase, phaseVersion)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(core.State)
		}
	}

	return r0
}

type State_SetReason struct {
	*mock.Call
}

func (_m State_SetReason) Return(_a0 core.State) *State_SetReason {
	return &State_SetReason{Call: _m.Call.Return(_a0)}
}

func (_m *State) OnSetReason(reason string) *State_SetReason {
	c := _m.On("SetReason", reason)
	return &State_SetReason{Call: c}
}

func (_m *State) OnSetReasonMatch(matchers ...interface{}) *State_SetReason {
	c := _m.On("SetReason", matchers...)
	return &State_SetReason{Call: c}
}

// SetReason provides a mock function with given fields: reason
func (_m *State) SetReason(reason string) core.State {
	ret := _m.Called(reason)

	var r0 core.State
	if rf, ok := ret.Get(0).(func(string) core.State); ok {
		r0 = rf(reason)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(core.State)
		}
	}

	return r0
}
